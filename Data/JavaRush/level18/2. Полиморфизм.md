## 2. Наследование — не панацея

Представьте, что вы для игры написали класс `Корова`. В нем есть много полей и методов. Объекты этого класса могут делать разные вещи: идти, есть, спать. Еще коровы звонят в колокольчик, когда ходят. Допустим, вы реализовали в классе все до мелочей.

А тут приходит заказчик проекта и говорит, что хочет выпустить новый уровень игры, где все действия происходят в море, а главным героем будет кит.

Вы начали проектировать класс `Кит` и поняли, что он лишь немного отличается от класса `Корова`. Логика работы обоих классов очень похожа, и вы решили использовать наследование.

Класс `Корова` идеально подходит на роль класса-родителя: в нем есть все необходимые переменные и методы. Достаточно только добавить киту возможность плавать. Но есть проблема: у вашего кита есть ноги, рога и колокольчик. Ведь эта функциональность реализована внутри класса `Корова`. Что тут можно сделать?

## 3. Переопределение метода

К нам на помощь приходит **переопределение (замена) методов**. Если мы унаследовали метод, который делает не совсем то, что нужно в нашем новом классе, мы можем заменить этот метод на другой.

Как же это делается? В нашем классе-потомке мы объявляем **такой же метод, как и метод класса-родителя, который хотим изменить.** Пишем в нем новый код. И все: как будто старого метода в классе-родителе и не было.

Вот как это работает:
![Pasted image 20231206151620.png](..%2Fimg%2Flevel18%2FPasted%20image%2020231206151620.png)

После наследования класса `Cow` и переопределения метода `printName`, класс `Whale` фактически содержит такие данные и методы:

![Pasted image 20231206151638.png](..%2Fimg%2Flevel18%2FPasted%20image%2020231206151638.png)
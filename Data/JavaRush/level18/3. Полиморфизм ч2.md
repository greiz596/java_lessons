## 1. Но и это еще не все

Предположим, в классе `Cow` есть метод `printAll()`, который вызывает два других метода. Тогда код будет работать так:
![Pasted image 20240123075017.png](..%2Fimg%2Flevel18%2FPasted%20image%2020240123075017.png)
![Pasted image 20240123075028.png](..%2Fimg%2Flevel18%2FPasted%20image%2020240123075028.png)


Обратите внимание: когда вызывается метод `printAll()`, написанный в классе `Cow`, у объекта типа `Whale`, используется метод `printName` класса `Whale`, а не `Cow`.

Главное — не в каком классе написан метод, а какой тип (класс) объекта, у которого этот метод вызван.

Наследовать и переопределять можно только нестатические методы. Статические методы не наследуются и, следовательно, не переопределяются.

Вот как выглядит класс `Whale` после применения наследования и переопределения методов:

## 2. Приведение типов

Тут есть еще более интересный момент. Т.к. класс при наследовании получает все методы и данные класса-родителя, объект этого класса разрешается сохранять (присваивать) в переменные класса-родителя (и родителя родителя, и т.д., вплоть до `Object`). Пример:
![Pasted image 20240123075135.png](..%2Fimg%2Flevel18%2FPasted%20image%2020240123075135.png)

## 3. Вызов метода объекта

При вызове метода у переменной, реальный метод вызывается у объекта. Этот механизм называется динамической диспетчеризацией методов.

Вот как это выглядит:

![Pasted image 20240123075214.png](..%2Fimg%2Flevel18%2FPasted%20image%2020240123075214.png)
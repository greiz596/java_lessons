## 1. Класс `Files`

Чтобы работать с файлами, есть шикарный утилитный класс — `java.nio.file.Files`. У него есть методы просто на все случаи жизни. Все методы этого класса статические и работают с объектами типа Path. Методов очень много, поэтому мы рассмотрим только основные:

![Pasted image 20231028150438.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150438.png)
![Pasted image 20231028150504.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150504.png)

## 2. Создание файлов и директорий
![Pasted image 20231028150547.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150547.png)

## 3. Копирование, перемещение и удаление

Копировать, перемещать и удалять файлы так же легко. На директории это тоже распространяется, но они должны быть пустые.
![Pasted image 20231028150606.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150606.png)


## 4. Проверка типа файла и факта существования
Когда у вас есть какой-то путь, полученный извне, вы бы хотели знать, это файл или директория. Ну и вообще: существует такой файл/директория или нет?

Для этого тоже есть специальные методы. Так же можно легко узнать длину файла:

![Pasted image 20231028150634.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150634.png)

## 5. Работа с содержимым файла

И наконец, есть целая серия методов, которые позволяют легко прочитать или записать содержимое файла. Пример:
![Pasted image 20231028150654.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150654.png)

## 6. Получение содержимого директории

Остался еще самый интересный метод — получение файлов и поддиректорий в заданной директории.

Для этого есть специальный метод — `newDirectoryStream()`, который возвращает специальный объект типа `DirectoryStream<Path>`. У него есть итератор(!), и с помощью этого итератора можно получить все файлы и поддиректории заданной директории.

Выглядит проще, чем кажется:
![Pasted image 20231028150732.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150732.png)

Объект `DirectoryStream<Path>` обладает двумя свойствами. Во-первых, у него есть итератор, который возвращает пути к файлам, и мы можем этот объект использовать внутри цикла `for-each`.

А во-вторых, этот объект является потоком данных, и его нужно закрывать с помощью метода `close()`, ну или использовать внутри `try`-with-resources.

## 7. Метод `Files.newInputStream`

Начиная с Java 5 классы `FileInputStream` и `FileOutputStream` стали считаться устаревшими. Одним из их минусов было то, что при создании объекта этих классов сразу происходит создание файлов на диске. И потенциально выбрасываются все ошибки, связанные с созданием файлов.

Впоследствии это было признано не самым хорошим решением. Поэтому для создания объектов-файлов рекомендуется использовать методы утилитного класса – `java.nio.Files`.

Вот сравнение старого подхода  и нового:
![Pasted image 20231028150813.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150813.png)
![Pasted image 20231028150825.png](..%2Fimg%2Flevel16%2FPasted%20image%2020231028150825.png)
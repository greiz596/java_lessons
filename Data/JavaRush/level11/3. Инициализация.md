### 1. Инициализация переменных 

Как вы уже знаете, в вашем классе можно объявить несколько переменных класса, и не просто объявить, а сразу инициализировать их стартовыми значениями.

```Java
class Cat  
{  
    public String name;  
    public int age = -1;  //Переменной `age` присваивается стартовое значение
  
    public Cat(String name, int age)  
    {  
        this.name = name;  
        this.age = age;  //Стартовое значение перетирается
    }  
  
    public Cat()  //Для age используется стартовое значение
    {  
        this.name = "Безымянный";  
    }  
}

Cat cat = new Cat("Васька", 2); //Так можно: вызовется первый конструктор
Cat cat = new Cat(); //Так можно: вызовется второй конструктор
```

Вот что будет происходить при выполнении кода `Cat cat = new Cat("Васька", 2);`:

-   Создается объект типа `Cat`
-   Инициализируются все переменные класса своими стартовыми значениями
-   Вызывается конструктор и выполняется его код.

### 2. Порядок инициализации переменных класса 

Переменные не просто инициализируются до работы конструктора: они еще и инициализируются в четко заданном порядке — **порядке объявления в классе.**

```Java
public class Solution  
{  
    public int a = b + c + 1;  
    public int b = a + c + 2;  
    public int c = a + b + 3;  
}
```

Такой код не скомпилируется, т.к. на момент создания переменной `а`, переменных `b` и `c` еще нет. А вот так записать можно, и этот код отлично скомпилируется и **будет работать.**

```Java
public class Solution  
{  
    public int a;  
    public int b = a + 2;  
    public int c = a + b + 3;  
}
```

Примечание: но вы же помните, что ваш код должен быть прозрачен для других разработчиков, так что такие приемы лучше не использовать — это ухудшает читаемость кода.

Тут нужно помнить, что все переменные класса до того, как им присвоили какое-либо значение, имеют значение **по умолчанию**. Для типа `int` это ноль.
Тут нужно помнить, что все переменные класса до того, как им присвоили какое-либо значение, имеют значение **по умолчанию**. Для типа `int` это ноль.

### 3. Константы 

Раз уж мы продолжаем разбирать процесс создания объекта, стоит затронуть вопрос инициализации констант — переменных класса, которые имеют модификатор `final`.

Если переменная класса имеет модификатор `final`, ей должно быть присвоено стартовое значение. Это вы уже знаете, и в этом нет ничего удивительного.

Но вот чего вы не знаете, так это того, что стартовое значение можно сразу не присваивать, если присвоить его в конструкторе. И это отлично будет работать для final-переменной. Единственное требование — если конструкторов несколько, final переменной должно быть присвоено значение во всех конструкторах.


```Java
public class Cat  
{  
    public final int maxAge = 25;  
    public final int maxWeight;  
  
    public Cat (int weight)  
    {  
        this.maxWeight = weight; // занесение стартового значения в константу  
    }  
}
```

### 4. Код в конструкторе 

И еще несколько важных замечаний насчет конструкторов. В будущем, в процессе изучения Java, вы столкнётесь с такими вещами как наследование, сериализация, исключения и т.п. Они все в разной степени влияют на работу конструкторов. Сейчас нет смысла сильно углубляться в эти темы, но хотя бы коснуться их мы как минимум обязаны.

Теоретически в конструкторе можно писать код любой сложности. Но не нужно этого делать. Пример:

```Java
class FilePrinter  
{  
    public String content;  
  
    public FilePrinter(String filename) throws Exception  
    {  
        FileInputStream input = new FileInputStream(filename);  
        byte[] buffer = input.readAllBytes();  
        this.content = new String(buffer);  
    }  
  
    public void printFile()  
    {  
        System.out.println(content);  
    }  
}
```

В конструкторе класса FilePrinter мы сразу открыли байтовый поток к файлу и прочитали его содержимое. Это достаточно сложное поведение, которое может потенциально привести к ошибкам.

А что если бы такого файла не было? А если бы были проблемы с его чтением? А если бы он был слишком большим?

Сложная логика подразумевает большую вероятность ошибок и код, который должен правильно обрабатывать исключения.

**Пример 1 – Сериализация**

В стандартной Java-программе есть много ситуаций, когда объекты вашего класса создаются не вами. Например, вы решили передать объект по сети: в таком случае Java-машина сама превратит ваш объект в набор байт, передаст его и снова по набору байт создаст объект.

И вот тут окажется, что на другом компьютере нет вашего файла, в конструкторе возникнет ошибка, и никто ее не обработает — что вполне себе способно привести к закрытию программы.

**Пример 2 — Инициализация полей класса**

Если конструктор вашего класса может выбросить checked-исключения – содержит ключевое слово throws, вы обязаны перехватить это исключение в методе, который создает ваш объект.

А если такого метода нет? Пример:

```Java
class Solution  
{  
    public FilePrinter reader = new FilePrinter("c:\\readme.txt");  
}
```

Конструктор класса `FilePrinter` содержит **checked-исключения**: вы не можете создать объект `FilePrinter`, не обернув его в try-catch. А try-catch можно писать только в методе

### 5. Конструктор базового класса 

В предыдущих лекциях мы немного обсуждали наследование. К сожалению, полностью наследование и ООП мы будем обсуждать на уровне, посвященном ООП, а конструкторов это касается уже сейчас.

Если вы унаследуете свой класс от другого класса, фактически в объект вашего класса будет встроен объект класса-родителя. Причем этот класс-родитель имеет свои переменные класса и свои конструкторы.

Поэтому вам очень важно знать и понимать, как же происходит инициализация параметров и вызов конструкторов, когда у вашего класса есть класс-родитель, чьи переменные и методы вы наследуете.

#### Классы

Как же нам узнать, в каком порядке инициализируются переменные и вызываются конструкторы? Давайте для начала напишем код двух классов, один из которых наследуется от другого:

```Java
class ParentClass  
{  
    public String a;  
    public String b;  
  
    public ParentClass()  
    {  
    }  
}  
  
class ChildClass extends ParentClass  
{  
    public String c;  
    public String d;  
  
    public ChildClass()  
    {  
    }  
}

Класс `ChildClass` наследуется от класса `ParentClass`.

```

Нам нужно определить, в каком же порядке инициализируются переменные и вызываются конструкторы. Сделать это нам поможет логирование.

#### Логирование

Логированием называется запись в консоль или файл действий, которые происходят во время работы программы.

Определить, что вызвался конструктор, довольно просто: нужно в теле конструктора написать в консоль сообщение об этом. А вот как определить, что переменная инициализировалась?

На самом деле это тоже не очень сложно: нужно написать специальный метод, который будет возвращать значение, которым инициализируется переменная класса, и логировать этот факт. Вот как может выглядеть этот код:

#### Финальный код

```Java
public class Main  
{  
    public static void main(String[] args)  
    {  
        ChildClass obj = new ChildClass();  // Создаем объект типа `ChildClass`
    }  
  
    public static String print(String text)   //Этот метод пишет в консоль переданный текст и возвращает его же
    {  
        System.out.println(text);  
        return text;  
    }  
}  
  
class ParentClass  //Объявляем `ParentClass`
{  
    public String a = Main.print("ParentClass.a");   //Пишем текст и им же инициализируем переменные
    public String b = Main.print("ParentClass.b");  
  
    public ParentClass()  //Пишем в консоль сообщение о вызове конструктора. Возвращаемое значение игнорируем.
    {  
        Main.print("ParentClass.constructor");  
    }  
}  
  
class ChildClass extends ParentClass  //Объявляем `ChildClass`
{  
    public String c = Main.print("ChildClass.c");   //Пишем текст и им же инициализируем переменные
    public String d = Main.print("ChildClass.d");  
  
    public ChildClass()  //Пишем в консоль сообщение о вызове конструктора. Возвращаемое значение игнорируем.
    {  
        Main.print("ChildClass.constructor");  
    }  
}

Вывод на экран

ParentClass.a 
ParentClass.b
ParentClass.constructor
ChildClass.c
ChildClass.d
ChildClass.constructor
```
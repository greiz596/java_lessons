### 1. Класс `StringTokenizer` 

И еще несколько самых частых сценариев работы со строками. Как разбить строку на несколько частей? Для этого есть несколько способов.

**Метод `split()`**

Первый способ разбить строку на несколько частей — использовать метод `split()`. В него в качестве параметра нужно передать регулярное выражение: специальный шаблон строки-разделителя.

Просто, но иногда такой подход избыточен. Если разделителей много, например, «пробел», «enter», «таб», «точка», приходится конструировать достаточно сложное регулярное выражение. Его сложно читать, а значит, в него сложно вносить изменения.

```java
String str = "Good news everyone!";
String[] strings = str.split("ne");
System.out.println(Arrays.toString(strings));
```

```
["Good ", "ws everyo", "!"]
```

**Класс `StringTokenizer`**

В Java есть специальный класс, вся работа которого — разделять строку на подстроки.

Этот класс не использует регулярные выражения: вместо этого в него просто передается строка, состоящая из символов-разделителей. Преимущества этого подхода в том, что он не разбивает сразу всю строку на кусочки, а потихоньку идет от начала к концу.

Класс состоит из конструктора и двух основных методов. В конструктор нужно передать строку, которую мы разбиваем на части, и строку — набор символов, используемых для разделения.


Возвращает следующую подстроку
```java
String nextToken()
```
Проверяет, есть ли еще подстроки.
```java
boolean hasMoreTokens()
```

```java
StringTokenizer имя = new StringTokenizer(строка, разделители);
```

Где строка — это `строка`, которую будем делить на части. А `разделители` — это строка, каждый символ которой считается символом-разделителем. Пример:


```java
String str = "Good news everyone!";

StringTokenizer tokenizer = new StringTokenizer(str,"ne");
while (tokenizer.hasMoreTokens())
{
   String token = tokenizer.nextToken();
   System.out.println(token);
}

Good  
ws
v
ryo !
```

Обратите внимание, что разделителем считается каждый символ строки, переданный второй строкой в конструктор `StringTokenizer`

### 2. Метод `String.format()` и класс `StringFormatter` 

У класса String есть статический метод `format()`: он позволяет задать шаблон объединения строки с данными. Общий вид этой команды такой:

```java
String имя = String.format(шаблон, параметры);
```

```java
String.format("Age=%d, Name=%s", age, name);
```

```
Age=12, Name=Amigo
```

```java
String.format("Width=%d, Height=%d", width, height);
```

```
Width=20, Height=10
```

```
String.format("Fullname=%s", name);
```
В метод `format()` первым параметром передают строку-шаблон, которая содержит весь нужный текст, а в местах, где нужно вставлять данные, написаны специальные символы типа `%d`, `%s` и т.п.

Вот эти `%s` и `%d` метод `format()` и заменяют на параметры, которые идут следом за строкой-шаблоном. Если нужно подставить строку, мы пишем `%s`, если число — `%d`. 

![Pasted image 20230424092428.png](..%2Fimg%2Flevel10%2FPasted%20image%2020230424092428.png)

Эти параметры указывают на тип данных, но есть еще параметры, которые указывают на порядок данных. Чтобы взять параметр по его номеру (нумерация начинается с единицы), нужно записать `%1$d` вместо `%d`. Пример:

`%3$d` возьмет 3-й параметр-переменную
, `%2$d` возьмет второй параметр.
`%d` возьмет самый первый параметр-переменную. Параметры шаблона `%s`, `%d` обращаются к переменным-параметрам независимо от параметров шаблона типа `%3$d` или `%2$s`

```java
String s = String.format("a=%3$d, b=%2$d, c=%d", 11, 12, 13);

`s` будет равна `"a=13, b=12, c=11"`
```

### 3. String Pool 

Все строки, которые были заданы в коде в [виде литералов](https://javarush.com/groups/posts/literaly-v-java), во время работы программы хранятся в памяти в так называемом `StringPool`. **`StringPool`** — это специальный массив для хранения строк. Цель его создания — оптимизация хранения строк:

Во-первых, строки, заданные в коде, нужно все-таки где-то хранить. Код — это команды, а данные (тем более такие большие как строки) нужно хранить в памяти отдельно от кода. В коде фигурируют только ссылки на объекты-строки.

Во-вторых, все одинаковые литералы можно хранить в памяти только один раз. Так оно и работает. Когда код вашего класса загружается Java-машиной, все строковые литералы добавляются в `StringPool`, если их там еще нет. Если уже есть, просто используется ссылка на строку из `StringPool`.

Поэтому если в своем коде вы присвоите нескольким `String`-переменным одинаковые литералы, переменные будут содержать одинаковые ссылки. В `StringPool` литерал будет добавлен только один раз, во всех остальных случаях будет браться ссылка на уже загруженную в `StringPool` строку.

Как это примерно работает:

```java
String a = "Привет";
String b = "Привет";
String c = "Пока";
```

```java
String[] pool = {"Привет", "Пока"};
a = pool[0];
b = pool[0];
c = pool[1];
```

Именно поэтому переменные `a` и `b` будут хранить одинаковые ссылки.

**Метод `intern()`**

Ну и самое интересное: вы можете программно добавить любую строку в `StringPool`. Для этого нужно просто вызвать метод `intern()` у `String`-переменной.

Метод `intern()` добавит строку в `StringPool`, если ее еще там нет, и вернет ссылку на строку из `StringPool`.

Если в `StringPool` добавить с помощью метода `intern()` две идентичные строки, метод вернет одинаковые ссылки. Это можно использовать чтобы сравнивать строки по ссылке. Пример:

Код

Примечание

```java
String a = new String("Привет");
String b = new String("Привет");
System.out.println(a == b);


false
```

```java
String a = new String("Привет");
String b = new String("Привет");

String t1 = a.intern();
String t2 = b.intern();
System.out.println(a == b);
System.out.println(t1 == t2);

false
true

```

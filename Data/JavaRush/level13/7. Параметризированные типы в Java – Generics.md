## 1. Все классы унаследованы от `Object`

Все классы в Java неявно (скрытно) унаследованы от класса `Object`.

Что такое наследование и как оно работает в Java, мы разберем в квесте Java Core. Сейчас же мы рассмотрим один простой факт, который из этого следует:

Переменной типа `Object` можно присвоить объект любого класса. Пример:

На этом хорошие новости заканчиваются. **Компилятор не следит за тем**, объект какого именно типа был сохранен в переменную типа `Object`, поэтому **вызвать методы, которые были у** сохраненного объекта, но которых нет у переменной типа `Object` нельзя.

Если нужно вызвать методы такого объекта, то сначала ссылку на него нужно сохранить в переменную правильного типа, а только потом вызвать методы у этой переменной:

![Pasted image 20230917132319.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917132319.png)

Просто так переменную типа `Object` нельзя присвоить переменной типа Scanner, даже если переменная типа `Object` хранит ссылку на объект типа `Scanner`. Зато это можно сделать, если использовать уже известный вам оператор приведения типа. В общем виде выглядит это так:

```java
Тип имя1 = (Тип) имя2;
```

**Приведение типа**

Если типы переменной и объекта не совпадают, возникнет ошибка `ClassCastException`. Пример:

![Pasted image 20230917134901.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917134901.png)

В Java есть способ обойти эту ошибку: существует способ проверить, какой на самом деле тип находится внутри переменной:

```java
имя instanceof Тип
```

Оператор `instanceof` проверяет, является ли переменная `имя` объектом типа `Тип`.

![Pasted image 20230917135002.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917135002.png)

## 2. Причина возникновения шаблонов (коллекции)
Возвращаемся к коллекциям.

Когда Java-разработчики только создавали класс `ArrayList`, они хотели сделать его универсальным, чтобы в нем можно было хранить объекты любого типа. Поэтому для хранения элементов они воспользовались массивом типа `Object`.

Сильная сторона такого подхода в том, что в коллекцию можно добавить объект любого типа.

Ну а слабых сразу несколько.

**Недостаток 1.**

Всегда приходилось писать оператор преобразования типа, когда доставали элементы из коллекции:

![Pasted image 20230917140332.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917140332.png)

**Недостаток 2.**

Не было гарантии, что в коллекции хранятся элементы определенного типа

![Pasted image 20230917140404.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917140404.png)

Данные в коллекцию могут заполняться где угодно:

- в другом методе
- в другой программе
- загружаться из файла
- получаться по сети

**Недостаток 3.**

Данные коллекции можно случайно поменять по незнанию.

Вы можете передать коллекцию, заполненную вашими данными в какой-то метод, а этот метод, написанный совсем другим программистом, добавит в вашу коллекцию свои данные.

По названию коллекции непонятно, какие именно типы данных можно в ней хранить. А даже если и дать переменной такое название, ссылку на нее можно передать в десяток методов, и уж там-то точно об изначальном имени переменной ничего не будет известно.

## 3. Дженерики

Все эти проблемы устраняет такая классная вещь в Java как дженерики (Generics).

Под дженериками в Java подразумевают возможность добавлять к типам типы-параметры. Таким образом получаются сложные составные типы. Такой составной тип в общем случае выглядит так:

```java
ОсновнойТип<ТипПараметр>
```

Все вместе — это именно тип. И он может использоваться там, где обычно можно использовать типы.
![Pasted image 20230917140500.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917140500.png)
![Pasted image 20230917140531.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917140531.png)

## 4. Как работают Generics

На самом деле Generics работают до ужаса примитивно.

Компилятор просто заменяет тип с параметром на него же, только без параметра. А при взаимодействии с его методами добавляет операцию приведения типа к типу-параметру:
![Pasted image 20230917140608.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917140608.png)

Т.е. по сути дженерики — это такая разновидность синтаксического сахара, как и autoboxing, только побольше. При autoboxing компилятор за нас добавляет методы для преобразования типа `int` к `Integer` и обратно, а для generics добавляет операторы приведения типа.

После того, как компилятор скомпилировал ваш код с дженериками, в нем все классы с параметрами были преобразованы просто в классы и операторы приведения типа. Информация о том, какие изначально были типы-параметры у переменных сложных типов, потерялась. Этот эффект еще называют стиранием типов.

Иногда программистам, которые пишут свои классы с типами-параметрами, очень не хватает информации о типах, которые туда передаются в качестве параметров. Как с этим борются и что из этого выходит, вы узнаете в квесте Java Collections.

## 5. Несколько фактов о дженериках

Еще несколько интересных фактов о дженериках.

У классов **может быть не один тип параметр, а несколько.** Выглядит это примерно так:

```java
ОсновнойТип<ТипПараметр1, ТипПараметр2, ТипПараметр3>
```

Собственно говоря, в этом нет ничего удивительного. Там, где компилятор может добавить оператор приведения к одному типу, он может добавить и несколько таких.

![Pasted image 20230917140750.png](..%2Fimg%2Flevel13%2FPasted%20image%2020230917140750.png)

Также сложные типы тоже можно **использовать в качестве параметров**. Выглядит это примерно так:

```java
ОсновнойТип<ТипПараметр<ТипПараметрПараметра>>
```

опустим, мы хотим создать список, который будет хранить списки строк. В таком случае мы получим примерно такой код:

```java
// список приветствий
ArrayList<String> listHello = new ArrayList<String>();
listHello.add("Привет");
listHello.add("Hi");

// список прощаний
ArrayList<String> listBye = new ArrayList<String>();
listBye.add("Пока");
listBye.add("Good Bye");

// список списков
ArrayList<ArrayList<String>> lists = new ArrayList<ArrayList<String>>();
lists.add(listHello);
lists.add(listBye);
```
В этой теме ты познакомишься с ещё одним принципом ООП — **наследованием**. Его применяют, когда нужно передать поля и методы от одного класса к другому.

Часто в программах нужно использовать один и тот же код в нескольких классах.

Например, есть класс `Animal`. Он описывает животное. У этого класса есть поля `weight` — вес и `isScratching` — царапается ли животное. В метод `say()` записана фраза, которой животное представляется:
```
class Animal {
    double weight; // вес животного
    boolean isScratching; // царапается ли животное

    public Animal() {
        weight = 0.0;
        isScratching = false;
    }

    public String say() {
        return "Я животное!";
    }
} 
```

Чтобы описать других животных, понадобятся те же поля и методы: у животных будут те же признаки и действия.

Можно не писать эти поля и методы заново в каждом классе, а создавать классы-наследники — то есть классы с такими же полями и методами. Для этого понадобится ключевое слово `extends` (англ. «расширяет», «наследует от»).

Например, ты хочешь создать класс `Fox`, который описывает лису. В нём должны быть те же поля и методы, что и у любого другого животного.

Можно сделать класс `Fox` наследником класса `Animal`. Понадобится конструкция `class Fox extends Animal`:
```
class Animal {
    double weight;
    boolean isScratching;

    public Animal() {
        weight = 0.0;
        isScratching = false;
    }

    public String say() {
        return "Я животное!";
    }
}

class Fox extends Animal { // класс Fox - наследник класса Animal
    private String color;  // цвет животного - дополнительное поле класса-наследника
} 
```

У класса `Fox` — те же поля и метод, что и у `Animal`. А ещё у него есть дополнительное поле `color` (цвет) — так тоже можно. Такое поле будет только у класса-наследника: передать его родителю не получится.

Обрати внимание: в Java у класса может быть сколько угодно потомков, но только один родитель. Если ты решишь сделать один класс наследником другого, ему не получится передать ещё и методы какого-нибудь третьего класса.

### Модификатор доступа `protected`

Класс-потомок наследует все поля и методы с модификаторами доступа `public` и `protected`.

Модификатор `protected` тебе ещё не знаком. Он работает так же, как модификатор по умолчанию, но дополнительно даёт доступ классам-наследникам даже за пределами пакета.

Если класс-потомок находится в одном пакете с классом-родителем, он наследует поля и методы с модификатором по умолчанию `package-private`.

А вот данные, которые помечены модификатором `private`, наследникам не передаются.

Теперь ты знаешь обо всех модификаторах доступа, которые есть в Java. Ниже — полная таблица:

### Область видимости модификаторов доступа

|Модификатор доступа|В классе|В пакете|В классе-наследнике|Везде|
|---|---|---|---|---|
|private|✅|❌|❌|❌|
|package-private (default)|✅|✅|❌|❌|
|protected|✅|✅|✅|❌|
|public|✅|✅|✅|✅|


### Объект дочернего класса в переменной класса-родителя

Ты уже знаешь, что переменные ссылочного типа могут хранить ссылку на класс. Например, можно создать переменную `fox` типа `Fox` и сохранить в ней объект этого класса:
```
Fox fox = new Fox(); 
```

Ещё в переменной с типом класса-родителя можно хранить объект **дочернего** класса. Например, объект «лиса» может храниться в переменной типа «животное», потому что любая лиса относится к классу «животные»:
```
Animal fox = new Fox(); 
```

Такой код сработает: произойдёт неявное расширяющее преобразование типов. Тип дочернего класса можно преобразовать в тип родителя или родителя родителя.

Эта цепочка заканчивается типом `Object` — родителем всех объектов в Java:
```
Object fox = new Fox(); // такой код сработает 
```

А вот наоборот не сработает: переменной с типом дочернего класса нельзя присвоить объект родительского класса. Например, переменной типа `Fox` нельзя присвоить объект класса `Animal`: каждая лиса — животное, но не каждое животное — лиса.
```
// не сработает, получим ошибку компиляции: incompatible types: Animal cannot be converted to Fox
Fox animal = new Animal(); 
```

Например, метод `returnAnimal` присваивает переменной `animal` объект типа `Fox`, если животное — лиса; и объект типа `Animal`, если это любое другое животное:
```
public Animal returnAnimal(String name) {
    Animal animal;
        if ("Лиса".equals(name)) { // метод equals сравнивает строки: если животное - лиса,
        animal = new Fox();    // создаётся объект типа Fox
    } else {
        animal = new Animal(); // иначе - объект типа Animal
    }
    return animal;
} 
```

### Задание
### 1
Создай два класса-наследника класса `Artist` (художник): пуантилист (`Pointillist`) и импрессионист (`Impressionist`). В дочерних классах создай конструкторы без параметров, чтобы программа вывела:
```
Художник - пуантилист
Художник - импрессионист 
```
Без решения
```Java

```

С решением
```Java
public class Main {

    public static void main(String[] args) {
             Pointillist y = new Pointillist();

       Impressionist x = new Impressionist();
    }
}

public class Artist {

}

public class Impressionist extends Artist {
  Impressionist(){
       System.out.println("Художник - импрессионист");
  }
}
public class Pointillist extends Artist {
    Pointillist(){
    System.out.println("Художник - пуантилист");
    }
}


// создай классы с конструкторами
```

### 2
Класс `Bus` — наследник класса `Car`.
```
public class Car {
}

public class Bus extends Car {
} 
```

![img.png](img%2Fimg.png)
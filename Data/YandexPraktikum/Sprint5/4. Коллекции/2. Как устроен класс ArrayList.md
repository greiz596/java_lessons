В этом уроке ты узнаешь, как устроен класс `ArrayList`. Это поможет понять, как его лучше использовать.

### `ArrayList` в иерархии коллекций

`ArrayList` наследуется от интерфейсов `Iterable` → `Collection` → `List`.
![img_4.png](img%2Fimg_4.png)

Ты уже знаешь, что интерфейс в Java — это список действий, которые можно выполнять с объектом. В них хранится только список доступных действий, а сама реализация — в классах-наследниках.

Класс `ArrayList` наследует:

- **от интерфейса `Iterable<T>`** — метод `iterator()`. Он помогает пройтись по всем элементам коллекции. Ещё говорят — проитерироваться по ней;
- **от интерфейса `Collection<E>`** — методы для работы с коллекциями. Например, добавить, удалить и найти элемент: `add(E e)`, `remove(E e)` и `contains(E e)`;
- **от интерфейса `List<E>`** — методы, которые нужны для списков. Например, добавить и получить элемент по индексу: `add(int index, E e)` и `get(int index)`.

Логика этих методов описана в конкретной реализации — классе `ArrayList`.

### Размер и вместимость списка

В списках типа `ArrayList` необязательно указывать количество элементов. Это связано с тем, что такие списки автоматически увеличивают **вместимость**.

У списков типа `ArrayList` есть свойства:

- **размер `size`** — фактическое количество элементов в списке. Его можно узнать методом `size()`;
- **вместимость** (англ. capacity) — количество элементов, которое можно поместить в список. По умолчанию оно равно 10.

Вместимость можно задать самостоятельно: указать в круглых скобках, когда объявляешь список. Это пригодится, когда ты заранее знаешь, что у тебя гораздо больше 10 элементов — например, 100.

```java
import java.util.ArrayList;

public class Praktikum {

    public static void main(String[] args) {

        // вместимость по умолчанию — 10 элементов
        ArrayList<String> arrayListWithDefaultCapacity = new ArrayList<>();

        // можно задать вместимость 33 элемента
        ArrayList<String> arrayListWithSetCapacity = new ArrayList<>(33);

        // фактический размер обоих списков — 0: в них пока нет элементов
        System.out.println(arrayListWithDefaultCapacity.size());
        System.out.println(arrayListWithSetCapacity.size());
    }
}
```

Когда размер списка становится равен вместимости, она автоматически увеличивается на 50%: вместо четырёх элементов станет шесть, а вместо 100 — 150.

Например, в список `arrayList` с изначальной вместимостью 2 добавляют по одному элементу. Вместимость и размер увеличатся по такому принципу:
```
ArrayList<Integer> arrayList = new ArrayList<>(2);  // capacity = 2, size = 0

arrayList.add(1); // capacity = 2, size = 1
arrayList.add(2); // capacity = 2, size = 2
arrayList.add(3); // capacity = 3, size = 3 (2 + 50% = 3)
arrayList.add(4); // capacity = 4, size = 4 (3 + 50% = 4)
arrayList.add(5); // capacity = 6, size = 5 (4 + 50% = 6)
arrayList.add(6); // capacity = 6, size = 6
arrayList.add(7); // capacity = 9, size = 7 (6 + 50% = 9) 
```

![img_5.png](img%2Fimg_5.png)

Какой из этого вывод?

Знания об устройстве конкретных реализаций пригодятся, если работаешь с большим объемом данных. `ArrayList` быстро справляется с поиском по индексу. А вот для вставки или удаления элемента может затормозить, потому что нужно расширить массив.

Пока что тебе это поможет лучше понять, как работают интерфейсы, и что наследует от них `ArrayList`.
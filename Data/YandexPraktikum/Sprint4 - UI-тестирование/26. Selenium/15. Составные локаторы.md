Локаторы могут быть **составными**: это значит, они состоят из нескольких простых локаторов.

Работает это так. Сначала ты строишь один локатор: он находит некоторый узел в DOM. А затем второй локатор ищет уже из того узла, на который указывает первый.

Допустим, внутри секции section есть два списка — ненумерованный и нумерованный:

```
<html>
 <head>
   <title> Интересный документ </title>
 </head>
 <body>
  <section>
   <div>
     <div>
        <ul>
         <li>пункт 1</li>
         <li>пункт 2</li>
         <li>пункт 3</li>
       </ul>
       <ol>
        <li>пункт 1</li>
        <li>пункт 2</li>
        <li>пункт 3</li>
      </ol>
     </div>
   </div>
  </section>
    <ul>
     <li>пункт 1</li>
     <li>пункт 2</li>
     <li>пункт 3</li>
    </ul>
    <ol>
     <li>пункт 1</li>
     <li>пункт 2</li>
     <li>пункт 3</li>
    </ol>
 </body>
</html>
 
```

Попробуем построить относительный путь, начиная с элемента ol: `.//ol`. Или с элемента ul — `.//ul`. XPath получится неправильным. Он вернёт два элемента ol из всего документа и два элемента ul из всего документа, потому что проберётся ещё и в списки вне секции.

Можно просто составить два подробных xpath: `.//section/div/div/ol` и `.//section/div/div/ul`.

Посмотри: у них общее начало `.//section/div/div`. Чтобы не повторять его для каждого локатора, можно создать один отдельный локатор: `.//section/div/div`. Его можно переиспользовать.

Это позволяет не дублировать код. А ещё облегчает правки: нужно будет изменить только один локатор, а не два.

### За чем важно следить в составных локаторах

Локатор, отвечающий за общую часть пути, должен однозначно находить единственный нужный элемент.

Следующий за ним локатор построит путь, который исходит из него. Если он найдёт неправильную точку, пойдёт не туда.

### Задание
### 1
![img_12.png](img%2Fimg_12.png)

Тебе уже удалось разобраться, как устроены юнит-тесты и зачем их пишут.

В этом уроке ты познакомишься с правилами, по которым их создают.

Правила помогают:

- быстро и удобно работать с тестами,
- находить ошибки,
- покрывать тестами всю систему.


### Один тест — одна проверка

В одном тесте лучше проверять что-то одно: так проще найти ошибку. Если написать тест с несколькими проверками, ты потратишь больше времени на поиски: не всегда очевидно, где именно тест сломался.


Например, система должна определить, совершеннолетний ли пользователь. Нужно протестировать метод `isAdult()`, который принимает на вход возраст `age` и возвращает `true`, если он больше или равен 18, или `false`, если это не так.



```
public boolean isAdult(int age) { // метод isAdult() принимает аргумент age — возраст пользователя
    int adultAge = 18; // установили возраст совершеннолетия
    return age >= adultAge; // вернётся результат сравнения аргумента age с возрастом совершеннолетия
} 
```

Если смешать все проверки в один тест, он будет выглядеть так:



```
public void isAdultWhenAgeIsDifferent() {
    int ageMoreThan18 = 25; // задали переменную, которая передаётся в метод
    // как аргумент для первого теста 

    boolean actualResult1 = isAdult(ageMoreThan18); // вызвали метод, который будем тестировать, 
    // передали ему переменную ageMoreThan18, а актуальный результат его работы запишется 
    // в переменную boolean actualResult1

    boolean expectedResult1 = true; // ожидаемый результат проверки — true:
    // мы передали в метод age = 25, а 25 > 18

    System.out.println(“Результат выполнения теста:”); // сообщение-подсказка для пользователя
    System.out.println(actualResult1 == expectedResult1); // сообщение с результатом тестирования: 
    // если фактический и ожидаемый результаты совпали, тест считается пройденным
    
    int ageLessThan18 = 10; // задали переменную, которая передаётся в метод 
    // как аргумент для второго теста

    boolean actualResult2 = isAdult(ageLessThan18); // вызвали метод, который будем тестировать, 
    // передали ему переменную ageLessThan18, а актуальный результат его работы запишется 
    // в переменную boolean actualResult2

    boolean expectedResult2 = false; // ожидаемый результат проверки — false:
    // мы передали в метод age = 10, а 10 < 18

    System.out.println(“Результат выполнения теста:”); // сообщение-подсказка для пользователя
    System.out.println(actualResult2 == expectedResult2); // сообщение с результатом тестирования: 
    // если фактический и ожидаемый результаты совпали, тест считается пройденным
} 
```

В этом тесте две проверки: с возрастом больше 18 — `ageMoreThan18` и меньше 18 — `ageLessThan18`. Если тест не пройдёт, ты не сможешь сходу разобраться, какой возраст система обрабатывает неправильно.

Чем больше проверок в одном тесте, тем сложнее найти причину ошибки.

Корректный тест для метода `isAdult()` содержит только один вызов метода — того, который тестируется. Он будет выглядеть так:



```
public void isAdultWhenAgeIsMoreThan18True() {
    int age = 25; // задали переменную, которая передаётся в метод как аргумент
    boolean actualResult = isAdult(age); // вызвали метод, который будем тестировать, 
    // передали ему переменную age, а актуальный результат его работы запишется 
    // в переменную boolean actualResult
    boolean expectedResult = true; // ожидаемый результат проверки — true:
    // мы передали в метод age = 25, а 25 > 18
    System.out.println(“Результат выполнения теста:”); // сообщение-подсказка для пользователя
    System.out.println(actualResult == expectedResult); // сообщение с результатом тестирования: 
    // если фактический и ожидаемый результаты совпали, тест считается пройденным
} 
```


### Независимость данных

Результаты тестирования одних методов нельзя включать в другие юнит-тесты.

Если так сделать, тесты и результаты будут зависеть друг от друга. И всё начнёт ломаться при любой ошибке внутри кода. Например, если в методе, из которого извлекли данные, при изменении появилась ошибка, она переходит и в новый тест.


Например, у тебя есть метод `public int getAge(String name)`. Он принимает параметр `name` — имя пользователя, а из базы данных возвращается его возраст `age`.

Тест будет выглядеть так:



```
public void isAdultWhenAgeIsMoreThan18True() {
    String name = "Вася"; // задали имя пользователя
    int age = getAge(name); // передали имя пользователя в метод в качестве 
    // параметра и получили его возраст
    boolean actualResult = isAdult(age);
    boolean expectedResult = true;
    System.out.println("Результат выполнения теста:");
    System.out.println(actualResult == expectedResult);
} 
```


Если в методе `getAge(String name)` есть баг, он будет возвращать неправильный возраст или ошибку. В таком случае и тест `isAdultWhenAgeIsMoreThan18True()` не будет проходить проверку, хотя проблема не в нём. Именно поэтому важно следить за тем, чтобы тесты были независимы.

Чтобы соблюсти правило атомарности и не допустить перехода ошибки, данные для теста нужно задавать вручную — например, объявив переменную. Тест будет выглядеть так:



```
public void isAdultWhenAgeIsMoreThan18True() {
    int age = 25; // зададим самостоятельно переменную, при помощи которой
    // получим результат из метода isAdult()
    boolean actualResult = isAdult(age); // передадим эту переменную в метод
    boolean expectedResult = true;
    System.out.println("Результат выполнения теста:");
    System.out.println(actualResult == expectedResult);
} 
```


### Независимость тестов

Важно, чтобы тесты были независимы друг от друга. Это значит, их можно запускать по одному и в любом порядке.

Например, у тебя в игре есть корзина с яблоками. Есть два теста: один проверяет добавление яблок в корзину, а другой — удаление из корзины.

Взаимозависимые тесты будут устроены так: первый тест кладёт яблоко в корзину и проверяет, что яблоко добавилось; второй достаёт именно это яблоко и проверяет, что яблок больше нет.

Независимые тесты будут устроены иначе: у каждого теста — своя корзина с яблоками, и каждый проверяет фактический результат согласно документации.

Если последовать первому сценарию, тестировать корзину в произвольном порядке и вносить новые тесты будет сложнее. Если последовать второму сценарию, результаты выполнения не будут зависеть друг от друга — тестирование станет более мобильным.
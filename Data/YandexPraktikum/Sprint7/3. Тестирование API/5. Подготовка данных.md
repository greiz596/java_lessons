В этом уроке ты узнаешь, как собирать и хранить данные для API-автотестов.

### Как подготовить данные

Представь: ты проверяешь, что в приложении Mesto можно создать карточку с новым местом.

Чтобы подготовить тестовые данные, нужно:

1. Изучить тестовый сценарий. Шаги помогут понять, какие данные понадобятся: например, название и ссылка на изображение.
2. Узнать из документации, какие поля и типы данных можно передавать в запросе. Так ты сможешь написать больше негативных проверок: проверишь, что будет, если передать значение другого типа или не передать никакое.
3. Проанализировать требования, чтобы определить граничные значения и классы эквивалентности. Так ты создашь оптимальный набор тестовых данных, который не будет перегружать сервер.

Например, в Mesto пользователю нужно ввести непустое название и ссылку на изображение по шаблону `host.domain(/image_path)`.
### Как хранить данные

Когда ты подготовишь тестовые данные, их нужно сохранить. Это можно сделать несколькими способами:

- в исходном виде,
- в коде тестов,
- формировать динамически,
- запрашивать у тестируемого приложения.
### В исходном виде

Данные можно сохранить в JSON- или XML-файле. Чтобы отправить запрос, нужно считать содержимое этого файла или передать путь к нему в метод, который выполняет запрос.

Вспомни, как сделать это в RestAssured:

Скопировать кодJAVA

```
@Test
public void createNewCard1() {
    File json = new File("src/test/resources/newCard.json"); // создание экземпляра класса File

    given()
        .header("Content-type", "application/json") // передеча Content-type в заголовке для указания типа файла
        .auth().oauth2("подставь_сюда_свой_токен") // передача токена для аутентификации
        .and()
        .body(json) // передача файла
        .when()
        .post("/api/cards") // отправка POST-запроса
        .then().statusCode(201); // проверка кода ответа
} 
```

### В коде

Если у данных простая структура, их можно хранить прямо в коде автотестов.

Ты уже умеешь писать тесты с параметризацией. Здесь она тоже понадобится, чтобы отделить логику тестов от данных.

Данные можно описать в виде моделей — Java-классов. Чтобы добавить данные, нужно создать экземпляры этих классов и заполнить их поля. Тебе уже удалось проделать похожее в уроке про сериализацию. Такой класс называется POJO.

Например, в модели карточки должны быть поля `name` и `link`:

Скопировать кодJAVA

```
public class Card {
    public final String name;
    public final String link;

    public Card(String name, String link) {
        this.name = name;
        this.link = link;
    }
} 
```

Тестовые данные — экземпляр класса `Card` — можно передать в запрос:

Скопировать кодJAVA

```
@Test
public void createNewCard2() {
    for (int i = 0; i < 10; i++) {
        Card card = new Card(String.format("%s-%d", "Москва", i),
                "https://code.s3.yandex.net/qa-automation-engineer/java/files/paid-track/sprint1/photoSelenium.jpg"); // экземпляр класса Card со значениями полей

        given()
                .header("Content-type", "application/json") // передача Content-type в заголовке для указания типа файла
                .auth().oauth2("подставь_сюда_свой_токен") // передача токена для аутентификации
                .and()
                .body(card) // передача объекта с данными
                .when()
                .post("/api/cards") // отправка POST-запроса
                .then().statusCode(201); // проверка кода ответа
    }
} 
```

Обрати внимание: чтобы такой код работал, нужно добавить в `pom.xml` зависимость Jackson. Она помогает преобразовать данные в формат JSON:

Скопировать кодXML

```
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.13.0</version>
</dependency> 
```

Когда данные хранятся в моделях, код легче адаптировать к изменениям в API.

Например, разработчики изменили название поля. Если данные хранятся в JSON-файлах, придётся исправлять название поля в каждом файле. А если в модели — нужно будет изменить только название поля класса.

### Динамическое формирование данных

Можно формировать уникальные наборы данных. Например, создавать из массивов случайные комбинации вида `Компания.Сервис`:

Скопировать кодJAVA

```
String[] companies = new String[] { "Яндекс", "Google" }; // массив компаний
String[] services = new String[] { "Такси", "Документы", "Почта", "Деньги" }; // массив сервисов

int randomCompany = new Random().nextInt(companies.length); // выбор случайной компании из массива
int randomService = new Random().nextInt(services.length); // выбор случайного сервиса из массива

// можно создать случайную комбинацию Компания.Сервис:
System.out.format("%s.%s", companies[randomCompany], services[randomService]); 
// строки отформатированы, чтобы название компании и сервиса выводились через точку 
```

Или формировать уникальные идентификаторы: например, добавлять к названию карточки случайное число:

Скопировать кодJAVA

```
Card card = new Card("Москва - " + new Random().nextInt(10),
        "https://code.s3.yandex.net/qa-automation-engineer/java/files/paid-track/sprint1/photoSelenium.jpg"); 
```

### Запрос данных у приложения

Например, ты тестируешь метод, который ставит лайк на фотографию в Mesto. Чтобы не добавлять фотографии для проверки самостоятельно, можно получить список фотографий от приложения.

Для этого нужно:

1. Вызвать метод, который возвращает фотографии.
2. Сохранить параметр `_id` первой фотографии из списка.
3. Вызвать метод, который ставит лайк, и передать параметр.
4. Вызвать метод, который удаляет лайк, и передать параметр.

В коде это выглядит так:

Скопировать кодJAVA

```
@Test
public void likeTheFirstPhoto() {
    String oauthToken = "введи_сюда_свой_токен";

    // получение списка фотографий и сохранение _id первой фотографии
    String photoId = given()
        .auth().oauth2(oauthToken) // аутентификация при выполнении запроса
        .get("/api/cards") // отправка GET-запроса
        .then().extract().body().path("data[0]._id"); // получение ID фотографии из массива данных

    // лайк первой фотографии
    given()
        .auth().oauth2(oauthToken) // аутентификация при выполнении запроса
        .put("/api/cards/{photoId}/likes", photoId) // отправка PUT-запроса
        .then().assertThat().statusCode(200); // проверка, что сервер вернул код 200

    // снять лайк с первой фотографии
    given()
        .auth().oauth2(oauthToken) // аутентификация при выполнении запроса
        .delete("/api/cards/{photoId}/likes", photoId) // отправка DELETE-запроса
        .then().assertThat().statusCode(200); // проверка, что сервер вернул код 200
} 
```

Если сохранять данные в коде, а не запрашивать их у приложения, можно пропустить серьёзные баги.

Представь приложение для заказа пиццы. Фронтенд отправляет API-методу запрос: имя клиента, его контактные данные, адрес доставки, способ оплаты и состав заказа. Все поля, кроме способа оплаты и списка товаров, — строки. Способ оплаты — перечисление с двумя возможными значениями: «наличными» и «по карте».

Если передать способ оплаты «наличными», нужно подтвердить заказ у клиента. Для этого метод автоматически отправляет письмо в кол-центр.

Если клиент выбрал оплату по карте, метод обращается к стороннему сервису: он проверяет, что оплата прошла, и заказ сразу отправляется на кухню.

В коде автотеста есть только два способа оплаты — наличными и по карте.

В приложении появился новый способ оплаты — криптовалютой. Если передать такой способ, API-метод тоже обратится к стороннему сервису — но уже к другому. Он проверяет, что перевод на кошелёк пиццерии прошёл успешно.

Новый способ оплаты не будет покрыт тестами.

Чтобы правильно обработать такую ситуацию, можно использовать дополнительные API-методы. Например, в приложении есть метод, который позволяет клиенту получить все возможные способы оплаты.

Если добавить вызов этого метода перед запуском теста, можно проверить, сколько в приложении способов оплаты:

Скопировать кодJAVA

```
given()
        .get("/api/v1/payments") // URL ресурса, к которому отправится GET-запрос
        .then().assertThat() // выполнить запрос и проверить:
        .body("result.payments",  // в теле ответа есть JSON c объектом result и массивом payments,
               hasSize(2)); // содержащий 2 элемента 
```

Если способов оплаты окажется больше двух, тест упадёт. Так ты сможешь понять, что в приложении произошли изменения и нужно доработать тесты.
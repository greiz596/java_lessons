Ты уже знаешь про многопоточность. Также в программировании есть **асинхронность**.

Обычно задачи выполняются друг за другом — это синхронный подход.

В **асинхронном** подходе задачи чередуются и выполняются частями. Первая задача прерывается, начинается вторая. Вторая останавливается, снова продолжается первая.

![img_6.png](img%2Fimg_6.png)

Например, ты варишь макароны: ставишь кастрюлю, наливаешь в неё воду. Вдруг пришло сообщение в телеграме. Если подход синхронный, «ответ на сообщение» — блокирующая задача. Ты не сможешь открыть мессенджер, пока не приготовишь еду.

Если подход асинхронный, можно отвлечься от кастрюли и ответить на сообщение. Когда отправишь ответ — продолжишь готовку.

![img_7.png](img%2Fimg_7.png)

### Зачем нужна асинхронность

Асинхронность помогает процессору не простаивать и по максимуму задействовать доступные ресурсы. Если задача стопорится по какой-то причине, её можно отложить и взяться за другую. А потом к ней вернуться.

В идеале асинхронный подход полностью избавляет от простоев и блокирующих операций.

### Чем асинхронность отличается от многопоточности

Многопоточность значит, что задачи выполняются параллельно — в нескольких потоках.

Асинхронность — внутри одного потока задачи могут прерываться. Например, одна остановилась, началась другая, потом снова вернулись к первой.

Многопоточность — это варить макароны и сосиски на двух разных конфорках. Асинхронность — это отвлечься от готовки на что-то другое, а потом снова к ней вернуться.

Одно не мешает другому — например, асинхронность может быть многопоточной.

### Многопоточная асинхронность

Задачи прерываются и «прыгают» из одного потока в другой.
Вот пример: ты готовишь пирог вместе с другом. Ты делаешь тесто, а друг — начинку. Оказывается, у вас нет ягод. Ты идешь в магазин. Друг отвлекается от начинки и доделывает тесто, а потом возвращается к начинке.

Вы с другом — два потока. Ты выполняешь одну задачу — готовишь тесто, затем переключаешься на другую — идёшь в магазин. Друг подхватывает твою задачу, а после возвращается к своей.

Пример из кода — программа проводит сложные вычисления. Чтобы посчитать до конца, нужны промежуточные результаты. Каждое вычисление раскидывается по потокам и иногда прерывается, если ждёт данные. Когда получает данные, продолжает работу.

Теперь ты знаешь, что такое многопоточность и асинхронность. Это помогает понять, почему автотесты должны быть атомарными и независимыми. Теория — [в шпаргалке](https://code.s3.yandex.net/qa-automation-engineer/java/track2/cheatsheets/sprint7/processes_threads_cheatsheet.pdf).
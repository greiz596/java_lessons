В прошлых уроках тебе удалось разобраться с пирамидой тестирования. Ты знаешь, как понять, сколько тестов должно быть на каждом уровне.

Теперь ты узнаешь, как определять процент покрытия. Эта метрика показывает, какой процент программы выполняется во время тестов.


### Юнит-тесты

С этим уровнем пирамиды тебе уже удалось познакомиться [в уроке «Оценка покрытия»](https://practicum.yandex.ru/learn/qa-automation-engineer-java-extended/courses/10a893c9-7ab5-4e44-9d80-ccb565018ed5/sprints/74350/topics/e54e46f8-66eb-4e12-b871-495eb4734acb/lessons/a4d7d348-cb3f-4c51-92bd-8e9302d33f94/).

Как ты помнишь, вручную считать не нужно: помогают инструменты. Например, Jacoco.

У такого подхода есть минус. Если какой-то пункт требований остался нереализованным, это не учитывается в оценке покрытия. Покрытие может быть 100%, но при этом будут ошибки.


### Е2E-тесты

E2E-тесты можно оценивать по требованиям и по тест-кейсам.

**По требованиям**. В идеальном мире происходит так: есть набор требований и набор тестов. С одним или несколькими пунктами требований можно сопоставить хотя бы один из тестов.

Например, есть требование: «Нельзя зарегистрироваться дважды с одним и тем же электронным адресом». И есть тест со сценарием — регистрируемся один раз, регистрируемся второй раз с тем же адресом. Требование покрыто.
![img_3.png](img%2Fimg_3.png)

Например, есть 10 требований, а связанных тестов — 5. Процент покрытия — 50%.


Связывать тесты и требования — долго и неудобно. Ещё тесты нужно постоянно обновлять, ведь требования меняются. Например, раньше в пароле было шесть символов, а потом требование поменяли — стало восемь.

Ещё один минус: даже если на требование написали тест, нет гарантий, что он проверяет его до конца.

Например, требование звучит так: пароль должен содержать не менее шести символов. Тест проверяет комбинацию `qwerty`. Ещё нужно протестировать граничные случаи: пять и семь символов.

Формально требование покрыто, но на самом деле проверяется не в полной мере.


**По тест-кейсам**. Можно сопоставить проверки с тест-кейсами и рассчитать покрытие так:
![img_4.png](img%2Fimg_4.png)

Например, для приложения составили 1000 тест-кейсов. Тесты написали на 500 из них. Значит, покрытие 500 / 1000 * 100 % = 50 %.


Такой подход точнее, чем способ с требованиями. В тест-кейсах указывают конкретные параметры, поэтому связать их с тестами проще.

Обрати внимание, что нужно следить за актуальностью тест-кейсов — и менять тесты, если что-то переписали.


### Интеграционные

Можно оценивать покрытие по тому, сколько ручек API протестировано:

![img_5.png](img%2Fimg_5.png)

Например, API состоит из 50 ручек. Интеграционные тесты написали на 25. Значит, тестовое покрытие 25 / 50 * 100 % = 50 %.

У этого подхода есть минус. Не учитывается, как детально протестированы обязательные параметры ручек. А ещё непонятно, применялись ли необязательные параметры.

Например, есть ручка GET-запроса — она ищет пользователей. Искать можно по двум параметрам: ID пользователя и его имя.

Эти параметры необязательные. Можно не указывать их — тогда поиск идёт по всему сразу. Ещё можно указать один или сразу оба параметра.

На ручку написали два теста — на запрос без параметров и на запрос с ID. Теста на запрос с именем нет. Формально ручка покрыта, ведь тест на неё есть. Но поиск по имени не проверили: он может не работать.

Если требования и тест-кейсы написаны для ручек API, можно оценивать покрытие так же, как в случае с E2E тестами.

Это последний урок в теме. Всё, что удалось узнать, — в [шпаргалке](https://code.s3.yandex.net/qa-automation-engineer/java/track2/cheatsheets/sprint8/testing_all_levels_cheatsheet.pdf).
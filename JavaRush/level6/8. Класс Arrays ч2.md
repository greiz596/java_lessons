### 1. Метод Arrays.fill()

Очень часто у Java-программистов при работе с массивами возникает задача: заполнить массив одинаковыми значениями. Можно, конечно, написать цикл и просто в цикле присвоить каждой ячейке массива определенное значение:

```Java
int[] x = new int[100];
for (int i = 0; i < x.length; i++) 
x[i] = 999;
```

А можно просто вызвать метод `Arrays.fill()`, который делает точно то же самое: заполняет переданный массив переданным значением. Вот как это выглядит:

```java
Arrays.fill(имя, значение)

int[] x = new int[100];
Arrays.fill(x, 999);
```

А еще с помощью метода `Arrays.fill()` можно заполнить определенным значением не весь массив, а его часть:
По старой доброй традиции Java, последний элемент не входит в диапазон.

```java
Arrays.fill(имя, первый, последний, значение)
```

```java
int[] x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

Arrays.fill(x, 3, 7, 999);


String str = Arrays.toString(x);
```
 
Заполняем ячейки `x[3]`, `x[4]`, `x[5]`, `x[6]` значениями `999`. Нумерация ячеек массива с нуля!  
  
Переменная `str` содержит значение:  

```
"[1, 2, 3, 999, 999, 999, 999, 8, 9, 10]"
```

Метод `Arrays.fill()` работает только с одномерными массивами. Если в него передать двумерный массив, он будет обработан как одномерный, со всеми вытекающими последствиями.


### 2. Метод Arrays.copyOf()

Как вы уже знаете, размер контейнера массива после его создания поменять нельзя.

А если очень хочется?

Ну, если очень хочется, то можно:

-   Создать новый массив нужной длины
-   Скопировать в него все элементы из первого массива.

Именно это, кстати, и делает метод `Arrays.copyOf()`. Вот как выглядит его вызов:


```java
тип[] имя2 = Arrays.copyOf(имя, длина);
```

Этот метод **не меняет существующий массив**, вместо этого он **создает новый массив** и копирует в него элементы старого массива.

Если элементы не поместились (длина меньше длины существующего массива), то лишние значения игнорируются.
Если длина нового массива больше длины старого, ячейки заполняются нулями.

```java
int[] x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

int[] x2 = Arrays.copyOf(x, 5);
String str2 = Arrays.toString(x2);

int[] x3 = Arrays.copyOf(x, 15);
String str3 = Arrays.toString(x3);
```

  
  
Переменная `str2` содержит значение:  

```
"[1, 2, 3, 4, 5]"
```

  
Переменная `str3` содержит значение:  

```
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0]"
```

### 3. Метод Arrays.copyOfRange()


А что делать, если вы хотите получить массив длиной 5 из массива длины 10, но чтобы в нем были не первые 5 элементов, а 5 последних?

Именно для этого случая вам пригодится еще один метод класса `Arrays` – метод `Arrays.copyOfRange()` Вот как выглядит его вызов:
По старой доброй традиции Java, последний элемент не входит в диапазон.

```
тип[] имя2 = Arrays.copyOfRange(имя, первый, последний);
```

```java
int[] x = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20};

int[] x2 = Arrays.copyOfRange(x, 5, 10);
String str2 = Arrays.toString(x2);

int[] x3 = Arrays.copyOfRange(x, 5, 15);
String str3 = Arrays.toString(x3);
```

  
  
Переменная `str2` содержит значение:  

```
"[16, 17, 18, 19, 20]"
```

  
Переменная `str3` содержит значение:  

```
"[16, 17, 18, 19, 20, 0, 0, 0, 0, 0]"
```

### 4. Метод Arrays.sort()

Ну и самое вкусное — **сортировка**. В программировании сортировать массивы приходится очень часто. Три самых частых действия при работе с массивами:

-   Сортировка массива
-   Поиск минимального (или максимального) элемента массива
-   Определение индекса элемента в массиве (поиск элемента в массиве)
И именно поэтому разработчики Java включили в класс `Arrays` метод `sort()`. Вот как выглядит его вызов:

```java
Arrays.sort(имя);
```


Этот метод сортирует переданный массив по возрастанию.

Пример:

```java
int[] x = {11, -2, 3, 0, 999, -20, 8, -20, 99, -20};

Arrays.sort(x);

String str = Arrays.toString(x);
```

   
Переменная `str` содержит значение:  

```
"[-20, -20, -20, -2, 0, 3, 8, 11, 99, 999]"
```

сортировать можно не только весь массив, но и часть массива. Вот как выглядит его вызов:

```java
Arrays.sort(имя, первый, последний);
```

```java
int[] x = {11, -2, 3, 0, 999, -20, 8, -20, 99, -20};

Arrays.sort(x, 4, 8);
String str = Arrays.toString(x);
```

Переменная `str` содержит значение:  

```
"[11, -2, 3, 0, -20, -20, 8, 999, 99, -20]"
```

В Java для сортировки массивов используется самый быстрый алгоритм сортировки — QuickSort. Скорость его сортировки зависит от размера массива и рассчитывается по формуле N*Log(N).


### 5. Метод Arrays.binarySearch()

Ну и последний из самых интересных методов класса `Arrays` умеет искать заданное значение в массиве. Это не обычный поиск, а так называемый бинарный поиск. Суть его заключается вот в чем:

-   Предварительно массив сортируется
-   Затем средний элемент массива сравнивается с искомым (с тем, который мы ищем).
-   Если искомый больше среднего, поиск продолжается в правой половине массива.
-   Если искомый элемент меньше среднего, поиск продолжается в левой половине массива

Благодаря тому, что массив отсортирован, можно за одно сравнение отбросить половину массива. Затем на следующем шаге отбросить еще половину и т.д.

```java
int index = Arrays.binarySearch(имя, значение);
```
Где `имя` — это имя массива, который нужно передать уже отсортированным (например, с помощью функции `Arrays.sort()`). `значение` — это тот элемент, который ищется в массиве. Метод возвращает результат — индекс искомого элемента в массиве (номер ячейки массива).

```java
int[] x = {11, -2, 3, 0, 999, -20, 8, -20, 99, -20};
Arrays.sort(x);

int index1 = Arrays.binarySearch(x, 0);
int index2 = Arrays.binarySearch(x, -20);
int index3 = Arrays.binarySearch(x, 99);
int index4 = Arrays.binarySearch(x, 5);
```

`x` содержит:  

```
{-20, -20, -20, -2, 0, 3, 8, 11, 99, 999}
```

`4`  
`1` (также подходили индексы `0` и `2`)  
`8`  
`-7`


Если искомых элементов в массиве **несколько**, просто вернется номер одного из них (нет гарантий, что это будет, допустим, самый первый или наоборот — самый последний из одинаковых элементов).
Если элемент в массиве **не найден, индекс будет отрицательным.****